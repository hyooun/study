# 아이템 24. 멤버 클래스는 되도록 static으로 만들라
중첩 클래스(nested class)란 다른 클래스 안에 정의된 클래스를 말한다.
이는 자신을 감싼 클래스에서만 쓰여야 하며, 그 외에 쓰임새가 있다면 top-level 클래스로 만들어야 한다.

중첩 클래스의 종류는 다음과 같고, static 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당한다.
- static 멤버 클래스
- non-static 멤버 클래스
- 익명(anonymous) 클래스
- 지역(local) 클래스

static 멤버 클래스는 바깥 클래스와 함께 쓰일 때 public 도우미 클래스로 쓰인다.
계산기가 지원하는 연산 종류를 정의하는 열거 타입을 예시로 생각해보자.
Operation 열거 타입은 Calculator 클래스의 public static 멤버 클래스가 되어야 한다.
그러면 Calculator의 클라이언트에서 Calculator.Operation.PLUS나 Calculator.Operation.MINUS 같은 형태로 원하는 연산을 참조할 수 있다.

반면 non-static의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.
그래서 non-staic 멤버 클래스의 인스턴스 메서드에서 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 참조를 가져올 수 있다.
정규화된 this란 `클래스명.this` 형태로 바깥 클래스의 이름을 명시하는 것을 말한다.
따라서 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 static으로 만들어야 한다.
non-static은 바깥 인스턴스 없이는 생성할 수 없기 때문이다.

non-static의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스가 인스턴스화 될 때 확립되며, 변경할 수 없다.
바깥 클래스의 인스턴스 메서드에서 멤버 클래스의 생성자를 호출할 때 자동으로 만들어지는 게 일반적이고, 드물게 직접 `바깥 인스턴스의 클래스.new MemberClass(args)`를 호출해 수동으로 만들기도 한다.

non-static 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다.
어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용하는 것이다.
예를 들어 Map 인터페이스 구현체들은 보통 keySet, entrySet, values 메서드가 반환하는 자신의 컬렉션 뷰를 구현할 때 non-static 멤버 클래스를 사용한다.
Set이나 List 같은 다른 컬렉션 인터페이스 구현체들도 비슷하다.

아래는 non-static 멤버 클래스의 예시로 자신의 iterator를 구현한다.
```java
public class MySet<E> extends AbstractSet<E> {
    ... // 생략

    @Override public Iterator<E> iterator() {
        return new MyIterator();
    }

    private class MyIterator implements Iterator<E> {
        ...
    }
}
```

### 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙이자.
static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다.
이 참조를 저장하기 위해서는 시간과 공간이 더 소비된다.
또한 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 발생할 수 있다([아이템 7](item7.md)).

private static 멤버 클래스는 흔히 바깥 클래스가 표현하는 객체의 한 부분을 나타낼 때 쓴다.
키와 값을 매핑시키는 Map 인스턴스를 생각해보자.
많은 Map 구현체는 각각의 key-value 쌍을 표현하는 엔트리(Entry) 객체들을 가지고 있다.
엔트리의 메서드들은 맵을 직접 사용하지 않기 때문에 엔트리를 private static 멤버 클래스가 가장 적합하다.

익명 클래스는 이름이 없고 바깥 클래스의 멤버도 아니다.
멤버와 달리 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다.
익명 클래스는 선언한 지점에서만 인스턴스를 만들 수 있고, instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
여러 인터페이스를 구현할 수 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수 없는 등의 많은 제약이 존재한다.
람다를 지원하기 전에는 작은 함수 객체나 처리 객체(process object)를 처리하는 데 주로 사용했다.

지역 클래스는 네 가지 중첩 클래스 중에 가장 드물게 사용한다.
지역변수를 선언할 수 있는 곳이면 어디서든 선언할 수 있고, 유효 범위도 지역변수와 같다. 

#### 참고자료
[정적, 비정적 내부 클래스 알고 사용하기](https://tecoble.techcourse.co.kr/post/2020-11-05-nested-class/)
