# 아이템 51. 메서드 시그니처를 신중히 설계하라
다음과 같은 API 설계 요령들을 준수하면 사용하기 쉽고 오류 가능성이 적은 API를 만들 수 있다.
## 1. 메서드 이름을 신중히 짓자.
항상 표준 명명 규칙([아이템 68](item68.md))을 따라야 한다.
이해할 수 있고, 같은 패키지에 속한 다른 메서드 이름들과 일관되게 짓는 것이 좋다.
너무 긴 이름은 피하고, 자바 라이브러리의 API 가이드를 참조하는 것도 좋다.

## 2. 편의 메서드를 너무 많이 만들지 말자.
메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하는 과정이 어려워진다.
인터페이스도 마찬가지이니 각 기능을 완벽히 수행하는 메서드만 제공해야 한다.

## 3. 매개변수 목록은 짧게 유지하자.
매개변수가 4개 이상이 되면 매개변수를 전부 기억하기가 어려워진다.
심지어 같은 타입이라면, 더 사용하기가 불편하다.
다음과 같은 방법으로 매개변수 목록을 짧게 줄일 수 있다.

첫 번째, 여러 매서드로 쪼갠다. 쪼개진 메서드 각각은 원래 매개변수 목록의 부분집합을 받는다.
잘못하면 메서드가 너무 많아질 수 있지만, 직교성(orthogonality)을 높여 오히려 메서드 수를 줄여주는 효과도 있다.
> 수학에서 두 벡터가 orthoronal하면 두 벡터의 내적은 0이다. 달리 말하면 두 벡터에는 서로 영향을 주는 성분이 전혀 없다는 의미이다.
> 소프트웨어 영역에서 직교성이 높다는 것은 "공통점이 없는 기능들이 잘 분리되어 있다." 혹은 "기능을 원자적으로 쪼개 제공한다." 정도의 의미로 해석할 수 있다.

java.util.List 인터페이스가 좋은 예시이다.
리스트에서 주어진 원소의 인덱스를 찾아야 하는데, 전체 리스트가 아닌 지정된 범위의 부분리스트에서 찾는다고 해보자.
이 기능을 하나의 메서드로 구현하려면 '부분리스트의 시작', '부분리스트의 끝', '찾을 원소'까지 총 3개의 매개변수가 필요하다.
List는 그 대신 부분리스트를 반환하는 subList 메서드와 주어진 원소의 인덱스를 알려주는 indexOf 메서드를 별개로 제공한다.
이러한 메서드를 잘 조합하면 원하는 기능을 구현할 수 있다.

두 번째는 매개변수 여러 개를 묶어주는 helper 클래스를 만드는 것이다.
일반적으로 이런 helper 클래스는 static member 클래스([아이템 24](item24.md))로 둔다.
여러 개의 매개변수를 독립된 하나의 개념으로 볼 수 있을 때 적합하다.
예를 들어 카드게임을 클래스로 만든다고 해보자.
그러면 메서드를 호출할 때 카드의 숫자와 무늬를 뜻하는 두 매개변수를 항상 같은 순서로 전달할 것이다.
이 둘을 묶는 helper 클래스를 만들어 하나의 매개변수로 주고받으면 API와 내부 구현이 깔끔해진다.

세 번째는 두 방법을 혼합한 것으로, 빌더 패턴([아이템 2](item2.md))을 메서드 호출에 응용한 것이다.
매개변수가 많고 일부는 생략해도 괜찮을 때 적합하다.
모든 매개변수를 하나로 추상화된 객체를 정의하고, 클라이언트에서 setter를 호출해 필요한 값을 설정하게 하는 방법이다.
이때 각 setter 메서드는 매개변수 하나 혹은 서로 연관된 몇 개만 설정하도록 한다.
클라이언트는 필요한 매개변수를 모두 설정한 다음, execute 메서드를 호출해 앞서 설정한 매개변수들의 유효성을 검사하고 설정이 완료된 객체를 넘겨 원하는 계산을 수행한다.

## 4. 매개변수의 타입으로는 클래스보다 인터페이스가 더 낫다.
매개변수로 적합한 인터페이스가 있다면 이를 구현한 클래스가 아닌 그 인터페이스를 직접 사용하자.
예를 들어 HashMap 대신 Map을 매개변수로 사용하는 식이다.
그러면 HashMap뿐만 아니라 TreeMap, ConcurrentHashMap 등 어떤 Map 구현체라도 인수로 건넬 수 있다.
인터페이스 대신 클래스를 사용하면 특정 구현체만 사용하도록 제한하는 꼴이다.

또한 boolean보다는 원소 2개짜리 열거 타입이 낫다.
열거 타입을 사용하면 코드를 읽고 쓰기가 더 쉬워진다.
또한 나중에 선택지를 추가하기도 쉽다.
```java
public enum TemperatureScale { FAHRENHEIT, CELCIUS }
```
위와 같이 온도를 정의한 열거 타입이 있고, 온도계 클래스의 static 팩터리 메서드가 이 열거 타입을 입력받아 적합한 온도계 인스턴스를 생성해준다고 해보자.
`Thermometer.newInstance(true)` 보다는 `Thermometer.newInstance(TemperatureScale.CELSIUS)`가 하는 일을 훨씬 명확히 알려준다.
나중에 다른 온도 타입을 추가하고 싶으면 열거 타입에만 추가하면 되고, 의존성을 개별 열거 타입 상수의 메서드 안으로 리팩터링해 넣을 수도 있다([아이템 34](item34.md)).
